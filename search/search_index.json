{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is a Python port of the JavaScript library, mourner/rbush.</p> <p>RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles. It's based on an optimized R-tree data structure with bulk insertion support.</p> <p>Spatial index is a special data structure for points and rectangles that allows you to perform queries like \"all items within this bounding box\" very efficiently (e.g. hundreds of times faster than looping over all items). It's most commonly used in maps and data visualizations.</p>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Instead of writing the entire library in Python, we implemented the core functionality in C++ and used pybind11 for better performance. So make sure you have a C++ compiler (e.g. <code>g++</code> or <code>clang++</code>) available in your environment.</li> <li>Make sure you have <code>git</code> installed in your environment.</li> <li>Install the package using pip: <pre><code>pip install git+https://github.com/lebr0nli/py-rbush.git\n</code></pre></li> </ol>"},{"location":"#performance","title":"Performance","text":"<p>We used the same way to benchmark the performance as the original JavaScript RBush. Check performance.py for more details.</p> <p>The following tables are the results of the performance test with Python 3.10 on an 8-core M1 CPU.</p> <ul> <li>Comparison with another Python port of RBush (but written in pure Python)</li> </ul> Test py-rbush pure Python py-rbush Improvement insert 1M items one by one 1.03s 51.67s 50.2x 1000 searches of 0.01% area 0.01s 2.90s 290.0x 1000 searches of 1% area 0.13s 9.03s 69.5x 1000 searches of 10% area 0.92s 42.02s 45.7x remove 1000 items one by one 0.005s 1.42s 284.0x bulk-insert 1M items 0.44s 17.01s 38.7x <ul> <li>Comparison with the original JavaScript RBush</li> </ul> Test py-rbush RBush Improvement insert 1M items one by one 1.03s 1.13s 1.0x 1000 searches of 0.01% area 0.01s 0.03s 3.0x 1000 searches of 1% area 0.13s 0.30s 2.3x 1000 searches of 10% area 0.92s 1.28s 1.4x remove 1000 items one by one 0.005s 0.009s 1.8x bulk-insert 1M items 0.44s 1.06s 2.4x"},{"location":"#upstream","title":"Upstream","text":"<p>This library is a straight-up port of several JavaScript libraries written by Vladimir Agafonkin:</p> <ul> <li>RBush 4.0.1</li> <li>QuickSelect 3.0.0</li> </ul> <p>All of these are published under MIT or ISC licenses.</p>"},{"location":"developer_guide/","title":"Developer Guide","text":""},{"location":"developer_guide/#requirements","title":"Requirements","text":"<ul> <li>python3 (&gt;=3.8)</li> <li>poetry</li> <li>g++ or clang++</li> <li>clang-format</li> </ul>"},{"location":"developer_guide/#installing-dependencies-and-building","title":"Installing Dependencies and Building","text":""},{"location":"developer_guide/#only-runtime-dependencies","title":"Only runtime dependencies","text":"<pre><code>make\n</code></pre>"},{"location":"developer_guide/#with-dev-dependencies","title":"With dev dependencies","text":"<pre><code>make dev-install\n</code></pre> <p>Note</p> <p>You need to install dev dependencies to run tests and linting.</p>"},{"location":"developer_guide/#with-docs-dependencies","title":"With docs dependencies","text":"<pre><code>make docs-install\n</code></pre> <p>Note</p> <p>You need to install docs dependencies to build documentation.</p>"},{"location":"developer_guide/#testing","title":"Testing","text":"<pre><code>make test\n</code></pre>"},{"location":"developer_guide/#linting","title":"Linting","text":""},{"location":"developer_guide/#checking","title":"Checking","text":"<pre><code>make lint\n</code></pre>"},{"location":"developer_guide/#auto-fixing","title":"Auto-fixing","text":"<pre><code>make fix\n</code></pre>"},{"location":"developer_guide/#benchmarking","title":"Benchmarking","text":"<pre><code>make bench\n</code></pre> <p>Note</p> <p>You can build rbush with <code>RBUSH_DEBUG=1 make</code> to let the benchmarking script can show the time taken by the C++ implementation.</p>"},{"location":"developer_guide/#serving-documentation","title":"Serving Documentation","text":"<pre><code>make docs\n</code></pre>"},{"location":"developer_guide/#cleaning-up","title":"Cleaning Up","text":"<pre><code>make clean\n</code></pre>"},{"location":"user_guide/","title":"User Guide","text":""},{"location":"user_guide/#overview","title":"Overview","text":"<p>The <code>rbush</code> module is an Python binding for a spatial indexing data structure (R-tree) implemented in C++ using pybind11. It provides efficient spatial searching and collision detection capabilities.</p>"},{"location":"user_guide/#classes","title":"Classes","text":""},{"location":"user_guide/#bbox","title":"BBox","text":"<p>Represents a bounding box with spatial coordinates.</p>"},{"location":"user_guide/#constructor","title":"Constructor","text":"<ul> <li><code>BBox()</code>: Default constructor</li> <li><code>BBox(min_x: float, min_y: float, max_x: float, max_y: float)</code>: Create bbox with specific coordinates</li> </ul>"},{"location":"user_guide/#attributes","title":"Attributes","text":"Attribute Type Description <code>min_x</code> double Minimum x-coordinate <code>min_y</code> double Minimum y-coordinate <code>max_x</code> double Maximum x-coordinate <code>max_y</code> double Maximum y-coordinate"},{"location":"user_guide/#methods","title":"Methods","text":"<ul> <li><code>area() -&gt; float</code>: Calculate the area of the bounding box</li> <li><code>contains(other: BBox) -&gt; bool</code>: Check if this bbox contains another</li> <li><code>margin() -&gt; float</code>: Calculate the perimeter of the bbox</li> <li><code>enlarged_area(other: BBox) -&gt; float</code>: Calculate enlarged area when extending to another bbox</li> <li><code>intersection_area(other: BBox) -&gt; float</code>: Calculate intersection area with another bbox</li> <li><code>extend(other: BBox)</code>: Extend current bbox to include another</li> </ul>"},{"location":"user_guide/#rbush","title":"RBush","text":"<p>Specialized R-tree implementation using Python dictionaries.</p>"},{"location":"user_guide/#constructor_1","title":"Constructor","text":"<ul> <li><code>RBush(max_entries: int = 9)</code>: Create R-tree with optional max entries per node</li> </ul>"},{"location":"user_guide/#methods_1","title":"Methods","text":"<ul> <li><code>clear()</code>: Remove all items from the R-tree</li> <li><code>insert(item: Dict)</code>: Insert an item into the R-tree</li> <li><code>load(items: List[Dict])</code>: Bulk insert items into the R-tree (faster than inserting one by one if you have lots of items)</li> <li><code>remove(item: Dict, equals: Optional[Callable] = None)</code>: Remove an item</li> <li><code>search(bbox: BBox) -&gt; List[Any]</code>: Search items within a bounding box</li> <li><code>collides(bbox: BBox) -&gt; bool</code>: Check if bbox collides with any stored item</li> <li><code>all() -&gt; List[Any]</code>: Retrieve all items</li> <li><code>serialize() -&gt; Dict[str, Any]</code>: Serialize the R-tree to a dictionary</li> <li><code>deserialize(data: Dict[str, Any])</code>: Deserialize the R-tree from a dictionary</li> <li><code>to_bbox(item: Dict) -&gt; BBox</code>: Convert item to its bounding box</li> </ul>"},{"location":"user_guide/#rbushbase","title":"RBushBase","text":"<p>Generic R-tree spatial index implementation that you can override <code>to_bbox</code> method to support custom item types.</p>"},{"location":"user_guide/#constructor_2","title":"Constructor","text":"<ul> <li><code>RBushBase(max_entries: int = 9)</code>: Create R-tree with optional max entries per node</li> </ul>"},{"location":"user_guide/#methods_2","title":"Methods","text":"<ul> <li><code>clear()</code>: Remove all items from the R-tree</li> <li><code>insert(item: Any)</code>: Insert an item into the R-tree</li> <li><code>load(items: List[Any])</code>: Bulk insert items into the R-tree (faster than inserting one by one if you have lots of items)</li> <li><code>remove(item: Any, equals: Optional[Callable] = None)</code>: Remove an item</li> <li><code>search(bbox: BBox) -&gt; List[Any]</code>: Search items within a bounding box</li> <li><code>collides(bbox: BBox) -&gt; bool</code>: Check if bbox collides with any stored item</li> <li><code>all() -&gt; List[Any]</code>: Retrieve all items</li> <li><code>serialize() -&gt; Dict[str, Any]</code>: Serialize the R-tree to a dictionary</li> <li><code>deserialize(data: Dict[str, Any])</code>: Deserialize the R-tree from a dictionary</li> <li><code>to_bbox(item: Any) -&gt; BBox</code>: Convert item to its bounding box</li> </ul> <p>Important</p> <p>By overriding <code>to_bbox</code> method, you can support custom item types in the R-tree, this method must be implemented in the derived class.</p>"},{"location":"user_guide/#usage-example","title":"Usage Example","text":""},{"location":"user_guide/#rbush_1","title":"RBush","text":"<pre><code>import math\n\nfrom rbush import RBush, BBox\n\n# Create R-tree\ntree = RBush()\n\n# Clear all items\ntree.clear()\n\n# Insert items\nitem1 = {\"min_x\": 0, \"min_y\": 0, \"max_x\": 10, \"max_y\": 10, \"id\": 1}\nitem2 = {\"min_x\": 5, \"min_y\": 5, \"max_x\": 15, \"max_y\": 15, \"id\": 2}\nitem3 = {\"min_x\": 10, \"min_y\": 10, \"max_x\": 20, \"max_y\": 20, \"id\": 3}\ntree.insert(item1)\ntree.load([item2, item3])\n\n# Search items\nresults = tree.search(BBox(-math.inf, -math.inf, math.inf, math.inf))\n\n# Check collision\ncollides = tree.collides(BBox(0, 0, 1, 1))\n\n# Remove item (default equals function is using object identity)\ntree.remove(item1)\n\n# Remove item with custom equals function (don't need to be the same object)\ntree.remove(item2.copy(), equals=lambda a, b: a[\"id\"] == b[\"id\"])\n\n# Retrieve all items\nall_items = tree.all()\n\n# Serialize the tree to dict\ntree_dict = tree.serialize()\n\n# Deserialize the tree from dict\ntree.deserialize(tree_dict)\n</code></pre>"},{"location":"user_guide/#rbushbase_1","title":"RBushBase","text":"<pre><code>from rbush import RBushBase, BBox\n\nclass MyItem:\n    def __init__(self, a: float, b: float, c: float, d: float) -&gt; None:\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\nclass MyRBush(RBushBase):\n    def to_bbox(self, item: MyItem) -&gt; BBox:\n        return BBox(item.a, item.b, item.c, item.d)\n\n# Create R-tree with custom item type\ntree = MyRBush()\n\n# Insert custom item\nitem = MyItem(0, 0, 10, 10)\ntree.insert(item)\n\n# And so on...\n</code></pre>"}]}